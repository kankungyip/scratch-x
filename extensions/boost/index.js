const ArgumentType=Scratch.ArgumentType,BlockType=Scratch.BlockType,Cast=Util.Cast,color=Util.Color,BLE=Scratch.BLE,Base64Util=Util.Base64Util,MathUtil=Util.MathUtil,RateLimiter=Util.RateLimiter,iconURI="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==",BoostBLE={service:"00001623-1212-efde-1623-785feabcd123",characteristic:"00001624-1212-efde-1623-785feabcd123",sendInterval:100,sendRateMax:20},BoostMotorMaxPowerAdd=10,BoostPingInterval=5e3,BoostColorSampleSize=5,BoostIO={MOTOR_WEDO:1,MOTOR_SYSTEM:2,BUTTON:5,LIGHT:8,VOLTAGE:20,CURRENT:21,PIEZO:22,LED:23,TILT_EXTERNAL:34,MOTION_SENSOR:35,COLOR:37,MOTOREXT:38,MOTORINT:39,TILT:40},BoostPortFeedback={IN_PROGRESS:1,COMPLETED:2,DISCARDED:4,IDLE:8,BUSY_OR_FULL:16},BoostPort10000223OrOlder={A:55,B:56,C:1,D:2},BoostPort10000224OrNewer={A:0,B:1,C:2,D:3};let BoostPort=BoostPort10000224OrNewer;const BoostColor={ANY:"any",NONE:"none",RED:"red",BLUE:"blue",GREEN:"green",YELLOW:"yellow",WHITE:"white",BLACK:"black"},BoostColorIndex={[BoostColor.NONE]:255,[BoostColor.RED]:9,[BoostColor.BLUE]:3,[BoostColor.GREEN]:5,[BoostColor.YELLOW]:7,[BoostColor.WHITE]:10,[BoostColor.BLACK]:0},BoostMessage={HUB_PROPERTIES:1,HUB_ACTIONS:2,HUB_ALERTS:3,HUB_ATTACHED_IO:4,ERROR:5,PORT_INPUT_FORMAT_SETUP_SINGLE:65,PORT_INPUT_FORMAT_SETUP_COMBINED:66,PORT_INFORMATION:67,PORT_MODEINFORMATION:68,PORT_VALUE:69,PORT_VALUE_COMBINED:70,PORT_INPUT_FORMAT:71,PORT_INPUT_FORMAT_COMBINED:72,OUTPUT:129,PORT_FEEDBACK:130},BoostHubProperty={ADVERTISEMENT_NAME:1,BUTTON:2,FW_VERSION:3,HW_VERSION:4,RSSI:5,BATTERY_VOLTAGE:6,BATTERY_TYPE:7,MANUFACTURER_NAME:8,RADIO_FW_VERSION:9,LEGO_WP_VERSION:10,SYSTEM_TYPE_ID:11,HW_NETWORK_ID:12,PRIMARY_MAC:13,SECONDARY_MAC:14,HW_NETWORK_FAMILY:15},BoostHubPropertyOperation={SET:1,ENABLE_UPDATES:2,DISABLE_UPDATES:3,RESET:4,REQUEST_UPDATE:5,UPDATE:6},BoostOutputSubCommand={START_POWER:1,START_POWER_PAIR:2,SET_ACC_TIME:5,SET_DEC_TIME:6,START_SPEED:7,START_SPEED_PAIR:8,START_SPEED_FOR_TIME:9,START_SPEED_FOR_TIME_PAIR:10,START_SPEED_FOR_DEGREES:11,START_SPEED_FOR_DEGREES_PAIR:12,GO_TO_ABS_POSITION:13,GO_TO_ABS_POSITION_PAIR:14,PRESET_ENCODER:20,WRITE_DIRECT_MODE_DATA:81},BoostOutputExecution={BUFFER_IF_NECESSARY:0,EXECUTE_IMMEDIATELY:16,NO_ACTION:0,COMMAND_FEEDBACK:1},BoostMotorEndState={FLOAT:0,HOLD:126,BRAKE:127},BoostMotorProfile={DO_NOT_USE:0,ACCELERATION:1,DECELERATION:2},BoostIOEvent={ATTACHED:1,DETACHED:0,ATTACHED_VIRTUAL:2},BoostMode={TILT:0,LED:1,COLOR:0,MOTOR_SENSOR:2,UNKNOWN:0},BoostMotorState={OFF:0,ON_FOREVER:1,ON_FOR_TIME:2,ON_FOR_ROTATION:3},numberToInt32Array=function(t){var o=new ArrayBuffer(4),o=new DataView(o);return o.setInt32(0,t),[o.getInt8(3),o.getInt8(2),o.getInt8(1),o.getInt8(0)]},int32ArrayToNumber=function(t){t=Uint8Array.from(t);return new DataView(t.buffer).getInt32(0,!0)};class BoostMotor{constructor(t,o){this._parent=t,this._index=o,this._direction=1,this._power=50,this._position=0,this._status=BoostMotorState.OFF,this._pendingDurationTimeoutId=null,this._pendingDurationTimeoutStartTime=null,this._pendingDurationTimeoutDelay=null,this._pendingRotationDestination=null,this._pendingRotationPromise=null,this.turnOff=this.turnOff.bind(this)}get direction(){return this._direction}set direction(t){this._direction=t<0?-1:1}get power(){return this._power}set power(t){this._power=0===t?0:MathUtil.scale(t,1,100,10,100)}get position(){return this._position}set position(t){this._position=t}get status(){return this._status}set status(t){this._clearRotationState(),this._clearDurationTimeout(),this._status=t}get pendingDurationTimeoutStartTime(){return this._pendingDurationTimeoutStartTime}get pendingDurationTimeoutDelay(){return this._pendingDurationTimeoutDelay}get pendingRotationDestination(){return this._pendingRotationDestination}get pendingRotationPromise(){return this._pendingRotationPromise}set pendingRotationPromise(t){this._pendingRotationPromise=t}_turnOn(){var t=this._parent.generateOutputCommand(this._index,BoostOutputExecution.EXECUTE_IMMEDIATELY,BoostOutputSubCommand.START_SPEED,[this.power*this.direction,MathUtil.clamp(this.power+BoostMotorMaxPowerAdd,0,100),BoostMotorProfile.DO_NOT_USE]);this._parent.send(BoostBLE.characteristic,t)}turnOnForever(){this.status=BoostMotorState.ON_FOREVER,this._turnOn()}turnOnFor(t){t=Math.max(0,t),this.status=BoostMotorState.ON_FOR_TIME,this._turnOn(),this._setNewDurationTimeout(this.turnOff,t)}turnOnForDegrees(t,o){t=Math.max(0,t);var e=this._parent.generateOutputCommand(this._index,BoostOutputExecution.EXECUTE_IMMEDIATELY^BoostOutputExecution.COMMAND_FEEDBACK,BoostOutputSubCommand.START_SPEED_FOR_DEGREES,[...numberToInt32Array(t),this.power*this.direction*o,MathUtil.clamp(this.power+BoostMotorMaxPowerAdd,0,100),BoostMotorEndState.BRAKE,BoostMotorProfile.DO_NOT_USE]);this.status=BoostMotorState.ON_FOR_ROTATION,this._pendingRotationDestination=this.position+t*this.direction*o,this._parent.send(BoostBLE.characteristic,e)}turnOff(t=!0){var o=this._parent.generateOutputCommand(this._index,BoostOutputExecution.EXECUTE_IMMEDIATELY,BoostOutputSubCommand.START_POWER,[BoostMotorEndState.FLOAT]);this.status=BoostMotorState.OFF,this._parent.send(BoostBLE.characteristic,o,t)}_clearDurationTimeout(){null!==this._pendingDurationTimeoutId&&(clearTimeout(this._pendingDurationTimeoutId),this._pendingDurationTimeoutId=null,this._pendingDurationTimeoutStartTime=null,this._pendingDurationTimeoutDelay=null)}_setNewDurationTimeout(t,o){this._clearDurationTimeout();const e=setTimeout(()=>{this._pendingDurationTimeoutId===e&&(this._pendingDurationTimeoutId=null,this._pendingDurationTimeoutStartTime=null,this._pendingDurationTimeoutDelay=null),t()},o);this._pendingDurationTimeoutId=e,this._pendingDurationTimeoutStartTime=Date.now(),this._pendingDurationTimeoutDelay=o}_clearRotationState(){null!==this._pendingRotationPromise&&(this._pendingRotationPromise(),this._pendingRotationPromise=null),this._pendingRotationDestination=null}}class Boost{constructor(t,o){this._runtime=t,this._runtime.on("PROJECT_STOP_ALL",this.stopAll.bind(this)),this._extensionId=o,this._ports=[],this._motors=[],this._sensors={tiltX:0,tiltY:0,color:BoostColor.NONE,previousColor:BoostColor.NONE},this._colorSamples=[],this._ble=null,this._runtime.registerPeripheralExtension(o,this),this._rateLimiter=new RateLimiter(BoostBLE.sendRateMax),this._pingDeviceId=null,this.reset=this.reset.bind(this),this._onConnect=this._onConnect.bind(this),this._onMessage=this._onMessage.bind(this),this._pingDevice=this._pingDevice.bind(this)}get tiltX(){return this._sensors.tiltX}get tiltY(){return this._sensors.tiltY}get color(){return this._sensors.color}get previousColor(){return this._sensors.previousColor}boostColorForIndex(o){return Object.keys(BoostColorIndex).find(t=>BoostColorIndex[t]===o)||BoostColor.NONE}motor(t){return this._motors[t]}stopAllMotors(){this._motors.forEach(t=>{t&&t.turnOff(!1)})}setLED(t){t=[t>>16&255,t>>8&255,255&t],t=this.generateOutputCommand(this._ports.indexOf(BoostIO.LED),BoostOutputExecution.EXECUTE_IMMEDIATELY^BoostOutputExecution.COMMAND_FEEDBACK,BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA,[BoostMode.LED,...t]);return this.send(BoostBLE.characteristic,t)}setLEDMode(){var t=this.generateInputCommand(this._ports.indexOf(BoostIO.LED),BoostMode.LED,0,!1);return this.send(BoostBLE.characteristic,t)}stopAll(){this.isConnected()&&this.stopAllMotors()}scan(){this._ble&&this._ble.disconnect(),this._ble=new BLE(this._runtime,this._extensionId,{filters:[{services:[BoostBLE.service],manufacturerData:{919:{dataPrefix:[0,64],mask:[0,255]}}}],optionalServices:[]},this._onConnect,this.reset)}connect(t){this._ble&&this._ble.connectPeripheral(t)}disconnect(){this._ble&&this._ble.disconnect(),this.reset()}reset(){this._ports=[],this._motors=[],this._sensors={tiltX:0,tiltY:0,color:BoostColor.NONE,previousColor:BoostColor.NONE},this._pingDeviceId&&(window.clearInterval(this._pingDeviceId),this._pingDeviceId=null)}isConnected(){let t=!1;return t=this._ble?this._ble.isConnected():t}send(t,o,e=!0){return!this.isConnected()||e&&!this._rateLimiter.okayToSend()?Promise.resolve():this._ble.write(BoostBLE.service,t,Base64Util.uint8ArrayToBase64(o),"base64")}generateOutputCommand(t,o,e,r){t=[0,BoostMessage.OUTPUT,t,o,e,...r];return t.unshift(t.length+1),t}generateInputCommand(t,o,e,r){t=[0,BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE,t,o].concat(numberToInt32Array(e)).concat([r]);return t.unshift(t.length+1),t}_onConnect(){this._ble.startNotifications(BoostBLE.service,BoostBLE.characteristic,this._onMessage),this._pingDeviceId=window.setInterval(this._pingDevice,BoostPingInterval),setTimeout(()=>{var t=[0,BoostMessage.HUB_PROPERTIES,BoostHubProperty.FW_VERSION,BoostHubPropertyOperation.REQUEST_UPDATE];t.unshift(t.length+1),this.send(BoostBLE.characteristic,t,!1)},500)}_onMessage(t){var o=Base64Util.base64ToUint8Array(t),t=o[2],e=o[3];switch(t){case BoostMessage.HUB_PROPERTIES:o[3]===BoostHubProperty.FW_VERSION&&(r=int32ArrayToNumber([36,2,0,16]),int32ArrayToNumber(o.slice(5,o.length))<r?(BoostPort=BoostPort10000223OrOlder,log.info("Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.")):BoostPort=BoostPort10000224OrNewer);break;case BoostMessage.HUB_ATTACHED_IO:var r=o[4],s=o[5];switch(r){case BoostIOEvent.ATTACHED:this._registerSensorOrMotor(e,s);break;case BoostIOEvent.DETACHED:this._clearPort(e);break;case BoostIOEvent.ATTACHED_VIRTUAL:}break;case BoostMessage.PORT_VALUE:var i=this._ports[e];switch(i){case BoostIO.TILT:this._sensors.tiltX=o[4],this._sensors.tiltY=o[5];break;case BoostIO.COLOR:this._colorSamples.unshift(o[4]),this._colorSamples.length>BoostColorSampleSize&&(this._colorSamples.pop(),this._colorSamples.every((t,o,e)=>t===e[0]))?(this._sensors.previousColor=this._sensors.color,this._sensors.color=this.boostColorForIndex(this._colorSamples[0])):this._sensors.color=BoostColor.NONE;break;case BoostIO.MOTOREXT:case BoostIO.MOTORINT:this.motor(e).position=int32ArrayToNumber(o.slice(4,8));break;case BoostIO.CURRENT:case BoostIO.VOLTAGE:case BoostIO.LED:break;default:log.warn("Unknown sensor value! Type: "+i)}break;case BoostMessage.PORT_FEEDBACK:var n,r=o[4],a=this.motor(e);a&&(n=r&BoostPortFeedback.IN_PROGRESS,r=r&(BoostPortFeedback.COMPLETED^BoostPortFeedback.DISCARDED),!n)&&r&&a.status===BoostMotorState.ON_FOR_ROTATION&&(a.status=BoostMotorState.OFF);break;case BoostMessage.ERROR:log.warn("Error reported by hub: "+o)}}_pingDevice(){this._ble.read(BoostBLE.service,BoostBLE.characteristic,!1)}_registerSensorOrMotor(t,o){(this._ports[t]=o)!==BoostIO.MOTORINT&&o!==BoostIO.MOTOREXT||(this._motors[t]=new BoostMotor(this,t));let e=null,r=1;switch(o){case BoostIO.MOTORINT:case BoostIO.MOTOREXT:e=BoostMode.MOTOR_SENSOR;break;case BoostIO.COLOR:e=BoostMode.COLOR,r=0;break;case BoostIO.LED:e=BoostMode.LED,this.setLEDMode(),this.setLED(255);break;case BoostIO.TILT:e=BoostMode.TILT;break;default:e=BoostMode.UNKNOWN}o=this.generateInputCommand(t,e,r,!0);this.send(BoostBLE.characteristic,o)}_clearPort(t){var o=this._ports[t];o===BoostIO.TILT&&(this._sensors.tiltX=this._sensors.tiltY=0),o===BoostIO.COLOR&&(this._sensors.color=BoostColor.NONE),this._ports[t]="none",this._motors[t]=null}}const BoostMotorLabel={A:"A",B:"B",C:"C",D:"D",AB:"AB",ALL:"ABCD"},BoostMotorDirection={FORWARD:"this way",BACKWARD:"that way",REVERSE:"reverse"},BoostTiltDirection={UP:"up",DOWN:"down",LEFT:"left",RIGHT:"right",ANY:"any"};class Scratch3BoostBlocks{static get EXTENSION_ID(){return"boost"}static get TILT_THRESHOLD(){return 15}constructor(t){this.runtime=t,this._peripheral=new Boost(this.runtime,Scratch3BoostBlocks.EXTENSION_ID)}getInfo(){return{id:Scratch3BoostBlocks.EXTENSION_ID,name:"BOOST",blockIconURI:iconURI,showStatusButton:!0,blocks:[{opcode:"motorOnFor",text:formatMessage({id:"boost.motorOnFor",default:"turn motor [MOTOR_ID] for [DURATION] seconds",description:"turn a motor on for some time"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.A},DURATION:{type:ArgumentType.NUMBER,defaultValue:1}}},{opcode:"motorOnForRotation",text:formatMessage({id:"boost.motorOnForRotation",default:"turn motor [MOTOR_ID] for [ROTATION] rotations",description:"turn a motor on for rotation"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.A},ROTATION:{type:ArgumentType.NUMBER,defaultValue:1}}},{opcode:"motorOn",text:formatMessage({id:"boost.motorOn",default:"turn motor [MOTOR_ID] on",description:"turn a motor on indefinitely"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.A}}},{opcode:"motorOff",text:formatMessage({id:"boost.motorOff",default:"turn motor [MOTOR_ID] off",description:"turn a motor off"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.A}}},{opcode:"setMotorPower",text:formatMessage({id:"boost.setMotorPower",default:"set motor [MOTOR_ID] speed to [POWER] %",description:"set the motor's speed without turning it on"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.ALL},POWER:{type:ArgumentType.NUMBER,defaultValue:100}}},{opcode:"setMotorDirection",text:formatMessage({id:"boost.setMotorDirection",default:"set motor [MOTOR_ID] direction [MOTOR_DIRECTION]",description:"set the motor's turn direction without turning it on"}),blockType:BlockType.COMMAND,arguments:{MOTOR_ID:{type:ArgumentType.STRING,menu:"MOTOR_ID",defaultValue:BoostMotorLabel.A},MOTOR_DIRECTION:{type:ArgumentType.STRING,menu:"MOTOR_DIRECTION",defaultValue:BoostMotorDirection.FORWARD}}},{opcode:"getMotorPosition",text:formatMessage({id:"boost.getMotorPosition",default:"motor [MOTOR_REPORTER_ID] position",description:"the position returned by the motor"}),blockType:BlockType.REPORTER,arguments:{MOTOR_REPORTER_ID:{type:ArgumentType.STRING,menu:"MOTOR_REPORTER_ID",defaultValue:BoostMotorLabel.A}}},{opcode:"whenColor",text:formatMessage({id:"boost.whenColor",default:"when [COLOR] brick seen",description:"check for when color"}),blockType:BlockType.HAT,arguments:{COLOR:{type:ArgumentType.STRING,menu:"COLOR",defaultValue:BoostColor.ANY}}},{opcode:"seeingColor",text:formatMessage({id:"boost.seeingColor",default:"seeing [COLOR] brick?",description:"is the color sensor seeing a certain color?"}),blockType:BlockType.BOOLEAN,arguments:{COLOR:{type:ArgumentType.STRING,menu:"COLOR",defaultValue:BoostColor.ANY}}},{opcode:"whenTilted",text:formatMessage({id:"boost.whenTilted",default:"when tilted [TILT_DIRECTION_ANY]",description:"check when tilted in a certain direction"}),func:"isTilted",blockType:BlockType.HAT,arguments:{TILT_DIRECTION_ANY:{type:ArgumentType.STRING,menu:"TILT_DIRECTION_ANY",defaultValue:BoostTiltDirection.ANY}}},{opcode:"getTiltAngle",text:formatMessage({id:"boost.getTiltAngle",default:"tilt angle [TILT_DIRECTION]",description:"the angle returned by the tilt sensor"}),blockType:BlockType.REPORTER,arguments:{TILT_DIRECTION:{type:ArgumentType.STRING,menu:"TILT_DIRECTION",defaultValue:BoostTiltDirection.UP}}},{opcode:"setLightHue",text:formatMessage({id:"boost.setLightHue",default:"set light color to [HUE]",description:"set the LED color"}),blockType:BlockType.COMMAND,arguments:{HUE:{type:ArgumentType.NUMBER,defaultValue:50}}}],menus:{MOTOR_ID:{acceptReporters:!0,items:[{text:"A",value:BoostMotorLabel.A},{text:"B",value:BoostMotorLabel.B},{text:"C",value:BoostMotorLabel.C},{text:"D",value:BoostMotorLabel.D},{text:"AB",value:BoostMotorLabel.AB},{text:"ABCD",value:BoostMotorLabel.ALL}]},MOTOR_REPORTER_ID:{acceptReporters:!0,items:[{text:"A",value:BoostMotorLabel.A},{text:"B",value:BoostMotorLabel.B},{text:"C",value:BoostMotorLabel.C},{text:"D",value:BoostMotorLabel.D}]},MOTOR_DIRECTION:{acceptReporters:!0,items:[{text:formatMessage({id:"boost.motorDirection.forward",default:"this way",description:"label for forward element in motor direction menu for LEGO Boost extension"}),value:BoostMotorDirection.FORWARD},{text:formatMessage({id:"boost.motorDirection.backward",default:"that way",description:"label for backward element in motor direction menu for LEGO Boost extension"}),value:BoostMotorDirection.BACKWARD},{text:formatMessage({id:"boost.motorDirection.reverse",default:"reverse",description:"label for reverse element in motor direction menu for LEGO Boost extension"}),value:BoostMotorDirection.REVERSE}]},TILT_DIRECTION:{acceptReporters:!0,items:[{text:formatMessage({id:"boost.tiltDirection.up",default:"up",description:"label for up element in tilt direction menu for LEGO Boost extension"}),value:BoostTiltDirection.UP},{text:formatMessage({id:"boost.tiltDirection.down",default:"down",description:"label for down element in tilt direction menu for LEGO Boost extension"}),value:BoostTiltDirection.DOWN},{text:formatMessage({id:"boost.tiltDirection.left",default:"left",description:"label for left element in tilt direction menu for LEGO Boost extension"}),value:BoostTiltDirection.LEFT},{text:formatMessage({id:"boost.tiltDirection.right",default:"right",description:"label for right element in tilt direction menu for LEGO Boost extension"}),value:BoostTiltDirection.RIGHT}]},TILT_DIRECTION_ANY:{acceptReporters:!0,items:[{text:formatMessage({id:"boost.tiltDirection.up",default:"up"}),value:BoostTiltDirection.UP},{text:formatMessage({id:"boost.tiltDirection.down",default:"down"}),value:BoostTiltDirection.DOWN},{text:formatMessage({id:"boost.tiltDirection.left",default:"left"}),value:BoostTiltDirection.LEFT},{text:formatMessage({id:"boost.tiltDirection.right",default:"right"}),value:BoostTiltDirection.RIGHT},{text:formatMessage({id:"boost.tiltDirection.any",default:"any",description:"label for any element in tilt direction menu for LEGO Boost extension"}),value:BoostTiltDirection.ANY}]},COLOR:{acceptReporters:!0,items:[{text:formatMessage({id:"boost.color.red",default:"red",description:"the color red"}),value:BoostColor.RED},{text:formatMessage({id:"boost.color.blue",default:"blue",description:"the color blue"}),value:BoostColor.BLUE},{text:formatMessage({id:"boost.color.green",default:"green",description:"the color green"}),value:BoostColor.GREEN},{text:formatMessage({id:"boost.color.yellow",default:"yellow",description:"the color yellow"}),value:BoostColor.YELLOW},{text:formatMessage({id:"boost.color.white",default:"white",desription:"the color white"}),value:BoostColor.WHITE},{text:formatMessage({id:"boost.color.black",default:"black",description:"the color black"}),value:BoostColor.BLACK},{text:formatMessage({id:"boost.color.any",default:"any color",description:"any color"}),value:BoostColor.ANY}]}},translations:{en:{"boost.color.any":"any color","boost.color.black":"black","boost.color.blue":"blue","boost.color.green":"green","boost.color.red":"red","boost.color.white":"white","boost.color.yellow":"yellow","boost.getMotorPosition":"motor [MOTOR_REPORTER_ID] position","boost.getTiltAngle":"tilt angle [TILT_DIRECTION]","boost.motorDirection.backward":"that way","boost.motorDirection.forward":"this way","boost.motorDirection.reverse":"reverse","boost.motorOff":"turn motor [MOTOR_ID] off","boost.motorOn":"turn motor [MOTOR_ID] on","boost.motorOnFor":"turn motor [MOTOR_ID] for [DURATION] seconds","boost.motorOnForRotation":"turn motor [MOTOR_ID] for [ROTATION] rotations","boost.seeingColor":"seeing [COLOR] brick?","boost.setLightHue":"set light color to [HUE]","boost.setMotorDirection":"set motor [MOTOR_ID] direction [MOTOR_DIRECTION]","boost.setMotorPower":"set motor [MOTOR_ID] speed to [POWER] %","boost.tiltDirection.any":"any","boost.tiltDirection.down":"down","boost.tiltDirection.left":"left","boost.tiltDirection.right":"right","boost.tiltDirection.up":"up","boost.whenColor":"when [COLOR] brick seen","boost.whenTilted":"when tilted [TILT_DIRECTION_ANY]"},"zh-cn":{"boost.color.any":"任何颜色","boost.color.black":"黑色","boost.color.blue":"蓝色","boost.color.green":"绿色","boost.color.red":"黄色","boost.color.white":"白色","boost.color.yellow":"黄色","boost.getMotorPosition":"马达 [MOTOR_REPORTER_ID] 位置","boost.getTiltAngle":"向[TILT_DIRECTION]倾角","boost.motorDirection.backward":"逆时针","boost.motorDirection.forward":"顺时针","boost.motorDirection.reverse":"反转","boost.motorOff":"关闭马达 [MOTOR_ID]","boost.motorOn":"开启马达 [MOTOR_ID]","boost.motorOnFor":"使马达 [MOTOR_ID]转动 [DURATION] 秒","boost.motorOnForRotation":"使马达 [MOTOR_ID]转动 [ROTATION] 圈","boost.seeingColor":"看到 [COLOR]积木 ?","boost.setLightHue":"将灯光颜色设为[HUE]","boost.setMotorDirection":"将马达[MOTOR_ID] 方向设为 [MOTOR_DIRECTION]","boost.setMotorPower":"将马达 [MOTOR_ID] 速度设为 [POWER]%","boost.tiltDirection.any":"任意方向","boost.tiltDirection.down":"下","boost.tiltDirection.left":"左","boost.tiltDirection.right":"右","boost.tiltDirection.up":"上","boost.whenColor":"当看到[COLOR]积木","boost.whenTilted":"当向[TILT_DIRECTION_ANY]倾斜"},"zh-tw":{"boost.color.any":"任何顏色","boost.color.black":"黑色","boost.color.blue":"藍色","boost.color.green":"綠色","boost.color.red":"紅色","boost.color.white":"白色","boost.color.yellow":"黃色","boost.getMotorPosition":"[MOTOR_REPORTER_ID] 轉向角度","boost.getTiltAngle":"傾斜角度 [TILT_DIRECTION]","boost.motorDirection.backward":"逆時針","boost.motorDirection.forward":"順時針","boost.motorDirection.reverse":"相反","boost.motorOff":"[MOTOR_ID] 停止","boost.motorOn":"[MOTOR_ID] 啟動","boost.motorOnFor":"[MOTOR_ID] 啟動 持續 [DURATION] 秒","boost.motorOnForRotation":"[MOTOR_ID] 啟動 持續 [ROTATION] 圈","boost.seeingColor":"看到顏色 [COLOR]？","boost.setLightHue":"LED 顏色設為 [HUE]","boost.setMotorDirection":"[MOTOR_ID] 方向設為 [MOTOR_DIRECTION]","boost.setMotorPower":"[MOTOR_ID] 動力設為 [POWER] %","boost.tiltDirection.any":"任何","boost.tiltDirection.down":"向下","boost.tiltDirection.left":"向左","boost.tiltDirection.right":"向右","boost.tiltDirection.up":"向上","boost.whenColor":"當顏色 [COLOR]  被看到","boost.whenTilted":"當傾斜 [TILT_DIRECTION_ANY]"}}}}motorOnFor(o){let e=1e3*Cast.toNumber(o.DURATION);return e=MathUtil.clamp(e,0,15e3),new Promise(t=>{this._forEachMotor(o.MOTOR_ID,t=>{t=this._peripheral.motor(t);t&&t.turnOnFor(e)}),setTimeout(t,e)})}motorOnForRotation(t){let e=360*Cast.toNumber(t.ROTATION);const r=Math.sign(e),o=(e=Math.abs(MathUtil.clamp(e,-36e4,36e4)),[]);this._forEachMotor(t.MOTOR_ID,t=>{o.push(t)});t=o.map(t=>{const o=this._peripheral.motor(t);return o?0===o.power?Promise.resolve():new Promise(t=>{o.turnOnForDegrees(e,r),o.pendingRotationPromise=t}):null});return Promise.all(t).then(()=>{})}motorOn(t){return this._forEachMotor(t.MOTOR_ID,t=>{t=this._peripheral.motor(t);t&&t.turnOnForever()}),new Promise(t=>{window.setTimeout(()=>{t()},BoostBLE.sendInterval)})}motorOff(t){return this._forEachMotor(t.MOTOR_ID,t=>{t=this._peripheral.motor(t);t&&t.turnOff()}),new Promise(t=>{window.setTimeout(()=>{t()},BoostBLE.sendInterval)})}setMotorPower(e){return this._forEachMotor(e.MOTOR_ID,t=>{var o=this._peripheral.motor(t);if(o)switch(o.power=MathUtil.clamp(Cast.toNumber(e.POWER),0,100),o.status){case BoostMotorState.ON_FOREVER:o.turnOnForever();break;case BoostMotorState.ON_FOR_TIME:o.turnOnFor(o.pendingDurationTimeoutStartTime+o.pendingDurationTimeoutDelay-Date.now())}}),new Promise(t=>{window.setTimeout(()=>{t()},BoostBLE.sendInterval)})}setMotorDirection(e){return this._forEachMotor(e.MOTOR_ID,t=>{var o=this._peripheral.motor(t);if(o){switch(e.MOTOR_DIRECTION){case BoostMotorDirection.FORWARD:o.direction=1;break;case BoostMotorDirection.BACKWARD:o.direction=-1;break;case BoostMotorDirection.REVERSE:o.direction=-o.direction;break;default:log.warn("Unknown motor direction in setMotorDirection: "+e.DIRECTION)}if(o)switch(o.status){case BoostMotorState.ON_FOREVER:o.turnOnForever();break;case BoostMotorState.ON_FOR_TIME:o.turnOnFor(o.pendingDurationTimeoutStartTime+o.pendingDurationTimeoutDelay-Date.now())}}}),new Promise(t=>{window.setTimeout(()=>{t()},BoostBLE.sendInterval)})}getMotorPosition(t){let o=null;switch(t.MOTOR_REPORTER_ID){case BoostMotorLabel.A:o=BoostPort.A;break;case BoostMotorLabel.B:o=BoostPort.B;break;case BoostMotorLabel.C:o=BoostPort.C;break;case BoostMotorLabel.D:o=BoostPort.D;break;default:return log.warn("Asked for a motor position that doesnt exist!"),!1}if(null!==o&&this._peripheral.motor(o)){let t=this._peripheral.motor(o).position;return o===BoostPort.A&&(t*=-1),MathUtil.wrapClamp(t,0,360)}return 0}_forEachMotor(t,o){let e;switch(t){case BoostMotorLabel.A:e=[BoostPort.A];break;case BoostMotorLabel.B:e=[BoostPort.B];break;case BoostMotorLabel.C:e=[BoostPort.C];break;case BoostMotorLabel.D:e=[BoostPort.D];break;case BoostMotorLabel.AB:e=[BoostPort.A,BoostPort.B];break;case BoostMotorLabel.ALL:e=[BoostPort.A,BoostPort.B,BoostPort.C,BoostPort.D];break;default:log.warn("Invalid motor ID: "+t),e=[]}for(const r of e)o(r)}whenTilted(t){return this._isTilted(t.TILT_DIRECTION_ANY)}isTilted(t){return this._isTilted(t.TILT_DIRECTION_ANY)}getTiltAngle(t){return this._getTiltAngle(t.TILT_DIRECTION)}_isTilted(t){return t!==BoostTiltDirection.ANY?this._getTiltAngle(t)>=Scratch3BoostBlocks.TILT_THRESHOLD:Math.abs(this._peripheral.tiltX)>=Scratch3BoostBlocks.TILT_THRESHOLD||Math.abs(this._peripheral.tiltY)>=Scratch3BoostBlocks.TILT_THRESHOLD}_getTiltAngle(t){switch(t){case BoostTiltDirection.UP:return 90<this._peripheral.tiltY?256-this._peripheral.tiltY:-this._peripheral.tiltY;case BoostTiltDirection.DOWN:return 90<this._peripheral.tiltY?this._peripheral.tiltY-256:this._peripheral.tiltY;case BoostTiltDirection.LEFT:return 90<this._peripheral.tiltX?this._peripheral.tiltX-256:this._peripheral.tiltX;case BoostTiltDirection.RIGHT:return 90<this._peripheral.tiltX?256-this._peripheral.tiltX:-this._peripheral.tiltX;default:log.warn("Unknown tilt direction in _getTiltAngle: "+t)}}whenColor(t){return t.COLOR===BoostColor.ANY?this._peripheral.color!==BoostColor.NONE&&this._peripheral.color!==this._peripheral.previousColor:t.COLOR===this._peripheral.color}seeingColor(t){return t.COLOR===BoostColor.ANY?this._peripheral.color!==BoostColor.NONE:t.COLOR===this._peripheral.color}setLightHue(t){var t=Cast.toNumber(t.HUE),o=360*(t=MathUtil.wrapClamp(t,0,100))/100,o=color.hsvToRgb({h:o,s:1,v:1}),o=color.rgbToDecimal(o);return this._peripheral._led=t,this._peripheral.setLED(o),new Promise(t=>{window.setTimeout(()=>{t()},BoostBLE.sendInterval)})}}Scratch.extensions.register(Scratch3BoostBlocks);