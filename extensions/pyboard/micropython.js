const WebSerial=Scratch.IO["WebSerial"],CTRL_A="",CTRL_B="",CTRL_C="",CTRL_D="",CTRL_E="",CTRL_F="",EOL=/\r?\n|(?<!\n)\r/,MAX_MESSAGES=10,WAIT_TIMEOUT=5e3,FREQ=5,BIN_CHUNK_SIZE=512,NOTIFY_MARKED="nfy",NOTIFY_REGEXP=new RegExp(`<${NOTIFY_MARKED}>([\\s\\S]*?)<\\/${NOTIFY_MARKED}>`),NOTIFY_CODE=`
import _thread
from machine import Timer
_state = {}
def _notify (t):
    try:
        for (id, [type, callback]) in _state.items():
            if type == 'in':
                print("<${NOTIFY_MARKED}>%s=%s</${NOTIFY_MARKED}>"%(id, callback()))
    except Exception as r:
        print("<${NOTIFY_MARKED}>error=%s</${NOTIFY_MARKED}>"%r)
def _notify_thread ():
    tim = Timer()
    tim.init(freq=${FREQ}, mode=Timer.PERIODIC, callback=_notify)
_thread.start_new_thread(_notify_thread, ())
`,isNumber=t=>!Number.isNaN(Number(t));class MicroPython{constructor(){this._port=null,this._filters=[],this._decoder=new TextDecoder,this._waitingFor=[],this._messages=[],this._lastMessage="",this._ready=!1,this.state={},this.reset=this.reset.bind(this),this._onConnect=this._onConnect.bind(this),this._onMessage=this._onMessage.bind(this)}scan(){this._port&&this._port.disconnect(),this._port=new WebSerial(this._extensionId,{filters:this._filters},this._onConnect,this.reset)}connect(){this._port&&this._port.connectPeripheral()}async disconnect(){this._port&&this._port.disconnect(),this.reset()}reset(){this._waitingFor=[],this._messages=[],this._lastMessage="",this._ready=!1,this.state={}}isConnected(){let t=!1;return t=this._port?this._port.isConnected():t}async _onConnect(){this._ready=!0,this._port.read(this._onMessage),await this.write(CTRL_B,">>> "),await this.write(CTRL_D,">>> "),await this.write(CTRL_C,">>> "),await this.send("import machine"),await this._startNotifications()}_onMessage(t){let i=""+this._lastMessage+this._decoder.decode(t);var e,t=i.match(NOTIFY_REGEXP),t=(t&&([t,e]=t[1].split("="),"True"===e||"False"===e?this.state[t]="True"===e:isNumber(e)?this.state[t]=Number(e):this.state[t]=e,i=i.replace(NOTIFY_REGEXP,"")),i.split(EOL));for(this._lastMessage=t.pop(),this._messages=this._messages.concat(t.filter(t=>0<t.length));this._messages.length>MAX_MESSAGES;)this._messages.shift();this._waitForSent()}_waitForSent(){var e=this._messages.concat(this._lastMessage);for(const r in this._waitingFor){var s=this._waitingFor[r];if(s&&this._lastMessage===s.waitFor.at(-1)){if(1===s.waitFor.length)return s.resolve(),void this._removeWait(r);for(let i=-1;i>=-s.waitFor.length;i--)for(let t=-1;t>=-e.length;t--){var a=e.at(t);if(s.waitFor.at(i)===a)return s.resolve(),void this._removeWait(r);if(a.includes("Error: ")||a.includes("Traceback"))return s.reject(new Error(a)),void this._removeWait(r)}}}}_removeWait(t){clearTimeout(t),this._waitingFor.splice(t,1)}_waitTimeout(t){var i=this._waitingFor[t];i&&i.reject(new Error(i.waitFor[0]+" timeout")),this._removeWait(t)}_waitFor(s,a=WAIT_TIMEOUT){return s=s.split(EOL),new Promise((t,i)=>{const e=setTimeout(()=>this._waitTimeout(e),a);this._waitingFor[e]={waitFor:s,resolve:t,reject:i}})}async write(t,i,e){this.isConnected&&this._ready&&(this._ready=!1,await this._port.write(t,"text"),this._ready=!0,i)&&await this._waitFor(i,e)}async send(t,i){this.isConnected&&await this.write(t=t+`\r
`,`>>> ${t}>>> `,i)}async run(t,i){this.isConnected&&(await this.write(CTRL_A,"raw REPL; CTRL-B to exit\r\n>"),await this.write(t),await this.write(CTRL_D,i?`>OK${i}${CTRL_D}${CTRL_D}>`:">OK"),await this.write(CTRL_B,'Type "help()" for more information.\r\n>>> '))}async setState(t,i,e,s){this.isConnected&&void 0===this.state[t]&&(this.state[t]=i,await this.run([s.replace("def callback",`def ${t}_callback`),`_state['${t}'] = ['${e}', ${t}_callback]`].join("\r\n")))}async _startNotifications(){this.isConnected&&await this.run(NOTIFY_CODE)}async save(i,e){var s=e+"/"+i.name;if(!await this._checkHash(s,i.hash)){var a=["import os","import binascii","os.chdir('/')","try:",`    os.mkdir('${e}')`,"except OSError:","    pass",`with open('${s}', 'wb') as f:`];let t=0;do{var r=t*BIN_CHUNK_SIZE,n=Math.min((t+1)*BIN_CHUNK_SIZE,i.content.length),r=i.content.slice(r,n);a.push(`    f.write(binascii.a2b_base64('${r}'))`),t++}while(t*BIN_CHUNK_SIZE<i.content.length);if(await this.run(a.join("\r\n")),!await this._checkHash(s,i.hash))throw new Error(`saving '${i.name}' failed`)}}async _checkHash(t,i){try{return await this.run(["import os","import binascii","import hashlib","os.chdir('/')","hash = hashlib.sha256()",`with open('${t}', 'rb') as f:`,"    while True:",`        c = f.read(${BIN_CHUNK_SIZE})`,"        if not c:","           break","        hash.update(c)","print(binascii.hexlify(hash.digest()).decode())"].join("\r\n"),i+`\r
`),!0}catch(t){return!1}}}self.MicroPython=MicroPython;